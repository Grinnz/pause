#!/usr/bin/env perl
use strict;
use warnings;
use lib 'lib';
use lib 't/lib';

use File::pushd;
use File::Temp ();
use JSON;
use Getopt::Long::Descriptive 0.104; # verbatim spacers -- rjbs, 2019-04-27
use Path::Class;
use Parse::CPAN::Packages;
use Parse::CPAN::Perms;

# Hey, wouldn't it be cool if there was a --starting-cpan option to say "clone
# this whole [mini]cpan mirror and load its 02 and 06 and then inject stuff
# into that.  Then you could see "what would happen in production?" (Almost.)
# -- rjbs, 2019-04-26

my ($opt, $usage) = describe_options(
  '%c %o TYPE:WHAT...',

  [ 'dir=s',          'target directory; by default uses a tempdir' ],
  [ 'verbose|v',      'print logs to STDERR as it goes'             ],

  [ 'packages|p=s',   '02packages file to prefill packages table'   ],
  [ 'perms|P=s',      '06perms file to prefill mods/primeur/perms'  ],
  [ 'default-user=s', 'default PAUSEID for uploads; default: LOCAL',
                      { default => 'LOCAL' } ],

  [ 'each',           'index at start and after each upload'        ],

  [ 'shell!',         'run a shell in the directory; default: true',
                      { default => 1 } ],
  [],
  [ \<<'EOT' ],
Other than the --switches, arguments are instructions in one of the forms
below.  For those that list PAUSEID, it may be omitted, and the default
user is used instead.

Valid instructions are:

  form                | meaning
  --------------------+-----------------------------------------------
  "-"                 | reindex now
  file:PAUSEID:FILE   | upload the named file as the named PAUSE user
  fake:PAUSEID:FILE   | generate a dist based on the given filename
  json:PAUSEID:JSON   | interpret the given JSON string as a faker struct
  perl:PAUSEID:PERL   | interpret the given Perl string as a faker struct
  fdir:DIRECTORY      | flat dir: upload all the files as the default user
  prog:file           | read a file containing a list of instructions
  cmd:"program"       | run the program, which should print out instructions

prog and cmd output can split instructions across multiple lines.  Lines that
begin with whitespace will be appended to the line preceding them.
EOT
);

$usage->die({ pre_text => "you didn't give any distfiles!\n\n" })
  unless my @instructions = @ARGV;

require PAUSE::TestPAUSE;

my $dir = $opt->dir;
my $tmpdir;
unless ($dir) {
  $tmpdir = File::Temp->newdir;
  $dir = "$tmpdir";
}

my $pause = PAUSE::TestPAUSE->init_new({
  tmpdir                 => dir($dir),
  email_sender_transport => 'Maildir',
  email_sender_transport_args => {
    dir => "$dir/Maildir", # Capital M to keep rjbs happy
  },
});

open my $log_fh, '>', "$dir/pause.log"
  or die "can't open $dir/pause.log for writing: $!\n";

$pause->pause_config_overrides->{LOG_CALLBACK} = sub {
  my (undef, undef, @what) = @_;
  push @what, "\n" unless $what[-1] =~ m{\n$};
  print {$log_fh} @what;
  print STDERR @what if $opt->verbose;
};

if ($opt->packages) {
  $pause->with_our_config(sub {
    my $dbh = PAUSE::dbh();

    my $p = Parse::CPAN::Packages->new($opt->packages);

    my $query = "INSERT INTO packages (package, version, dist, status) VALUES (?, ?, ?, ?);";

    my $count = 0;

    print "Inserting packages from " . $opt->packages . "...\n";

    $dbh->begin_work;

    for my $pkg ($p->packages) {
      dbh_do($dbh, $query, {},
        $pkg->package,
        $pkg->version,
        $pkg->distribution->prefix,
        "indexed",
      );

      $count++;
    }

    $dbh->commit;

    print "\t...done! Inserted $count packages\n";
  });
}

if ($opt->perms) {
  $pause->with_our_config(sub {
    my $dbh = PAUSE::dbh();

    my $p = Parse::CPAN::Perms->new($opt->perms);

    my $perms_data = $p->perms;

    my %queries = (
      m => "INSERT INTO mods    (modid,   userid) VALUES (?, ?)",
      f => "INSERT INTO primeur (package, userid) VALUES (?, ?)",
      c => "INSERT INTO perms   (package, userid) VALUES (?, ?)",
    );

#    my %inserted;

    my $count = 0;

    print "Inserting perms from " . $opt->perms . "...\n";

    $dbh->begin_work;

    for my $pkg (keys %$perms_data) {
      for my $user (keys %{ $perms_data->{$pkg} }) {
        my $perm = $perms_data->{$pkg}->{$user};

#        # Add a users entry for the user ?
#        unless ($inserted{$user}++) {
#          dbh_do($dbh, "INSERT INTO users (userid, ustatus) VALUES (?, ?)", {},
#            $user, 'active',
#          );
#        }

        my $query = $queries{$perm} || die "Unknown perm flag $perm\n";

        dbh_do($dbh, $query, {},
          $pkg, $user,
        );

        $count++;
      }
    }

    $dbh->commit;

    print "\t...done! Inserted $count permissions\n";
  });
}

my $JSON = JSON->new->relaxed(1);

my $index_clean;

INSTRUCTION: while (my $instruction = shift @instructions) {
  # file:PAUSEID:FILE   | upload the named file as the named PAUSE user
  # cmd:"program"       | run the program, which should print out filenames
  # fake:PAUSEID:FILE   | generate a dist based on the given filename
  # json:PAUSEID:JSON   | interpret the given JSON string as a faker struct
  # perl:PAUSEID:PERL   | interpret the given Perl string as a faker struct

  if ($instruction eq '-') {
    $pause->test_reindex;
    $index_clean = 1;
    next INSTRUCTION;
  }

  if ($opt->each && ! $index_clean) {
    $pause->test_reindex;
    $index_clean = 1
  }

  my ($type, $rest) = split /:/, $instruction, 2;

  if ($type eq 'cmd') {
    my @lines = `$rest`;
    chomp @lines;

    unfold_lines(\@lines);

    print {$log_fh} ">>>> ran `$rest` and unshifted results to queue\n";
    print {*STDERR} ">>>> ran `$rest` and unshifted results to queue\n"
      if $opt->verbose;

    unshift @instructions, @lines;
    next INSTRUCTION;
  }

  if ($type eq 'prog') {
    my @lines = grep {; chomp; length && ! /^#/ }
                split /\n/, file($rest)->slurp;

    unfold_lines(\@lines);

    print {$log_fh} ">>>> read '$rest' and unshifted results to queue\n";
    print {*STDERR} ">>>> read '$rest' and unshifted results to queue\n"
      if $opt->verbose;

    unshift @instructions, @lines;
    next INSTRUCTION;
  }

  if ($type eq 'fdir') {
    $rest =~ s/\A~/$ENV{HOME}/; # for my own sake -- rjbs, 2019-04-26
    my @to_inject = map {; "file:$_" } grep {; -f } <$rest/*>;

    print {$log_fh} ">>>> files found in $rest and to be added: @to_inject\n";
    print {*STDERR} ">>>> files found in $rest and to be added: @to_inject\n"
      if $opt->verbose;

    unshift @instructions, @to_inject;
    next INSTRUCTION;
  }

  my ($lhs, $rhs) = split /:/, $rest, 2;
  my $user  = defined $rhs ? $lhs : $opt->default_user;
  my $param = defined $rhs ? $rhs : $lhs;

  if ($type eq 'fake') {
    $pause->upload_author_fake($user => $param);
    $index_clean = 0;
    print {$log_fh} ">>>> Just uploaded fake from $user/$param\n";
    print {*STDERR} ">>>> Just uploaded fake from $user/$param\n" if $opt->verbose;
    next;
  }

  if ($type eq 'file') {
    $param =~ s/\A~/$ENV{HOME}/; # for my own sake -- rjbs, 2019-04-26
    $pause->upload_author_file($user => $param);
    $index_clean = 0;
    print {$log_fh} ">>>> Just uploaded $user/$param\n";
    print {*STDERR} ">>>> Just uploaded $user/$param\n" if $opt->verbose;
    next;
  }

  my $data = $type eq 'json' ? $JSON->decode($param)
           : $type eq 'perl' ? insane_safe_eval($param)
           : die "didn't recognize instruction type: $instruction\n";

  $pause->upload_author_fake($user => $data);
  $index_clean = 0;
  print {$log_fh} ">>>> Just uploaded fake for $user/$param\n";
  print {*STDERR} ">>>> Just uploaded fake for $user/$param\n" if $opt->verbose;
}

sub insane_safe_eval {
  my ($perl) = @_;
  my $pid = open my $fh, '-|',
    $^X, '-MJSON', '-E', "say encode_json($perl)";

  die "couldn't spawn $^X: $!" unless $pid;

  my $json = do { local $/; <$fh> };

  close $fh or die "error closing pipe: $!";

  $JSON->decode($json);
}

$pause->test_reindex unless $index_clean;

close $log_fh or warn "error closing $dir/pause.log: $!";

if ($opt->shell) {
  my $chdir_guard = pushd($dir);
  system($ENV{SHELL});
}

sub unfold_lines {
  my ($lines) = @_;
  for my $i (reverse 1 .. $#$lines) {
    next unless $lines->[$i] =~ /^\s/;
    $lines->[$i - 1] .= $lines->[$i];
    splice @$lines, $i, 1;
  }
}

sub dbh_do {
  my ($dbh, @args) = @_;

  my $ret;

  # Capture errors so we can hopefully provide some
  # useful debug.
  eval {
    $ret = $dbh->do(@args);
  };

  my $err = "";
  $err = $dbh->errstr unless defined $ret;
  $err ||= $@;

  die "Failed insertion (@args): $err\n" if $err;
}

1;
